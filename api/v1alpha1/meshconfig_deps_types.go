// Copyright Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by hack/api_transformer/main.go. DO NOT EDIT.

package v1alpha1

import (
	k8sv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// TLS connection mode
// +kubebuilder:validation:Enum=DISABLE;SIMPLE;MUTUAL;ISTIO_MUTUAL
type ClientTLSSettingsTLSmode string

const (
	// Do not setup a TLS connection to the upstream endpoint.
	ClientTLSSettingsTLSmodeDisable ClientTLSSettingsTLSmode = "DISABLE"
	// Originate a TLS connection to the upstream endpoint.
	ClientTLSSettingsTLSmodeSimple ClientTLSSettingsTLSmode = "SIMPLE"
	// Secure connections to the upstream using mutual TLS by presenting
	// client certificates for authentication.
	ClientTLSSettingsTLSmodeMutual ClientTLSSettingsTLSmode = "MUTUAL"
	// Secure connections to the upstream using mutual TLS by presenting
	// client certificates for authentication.
	// Compared to Mutual mode, this mode uses certificates generated
	// automatically by Istio for mTLS authentication. When this mode is
	// used, all other fields in `ClientTLSSettings` should be empty.
	ClientTLSSettingsTLSmodeIstioMutual ClientTLSSettingsTLSmode = "ISTIO_MUTUAL"
)

// SSL/TLS related settings for upstream connections. See Envoy's [TLS
// context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto.html#common-tls-configuration)
// for more details. These settings are common to both HTTP and TCP upstreams.
//
// For example, the following rule configures a client to use mutual TLS
// for connections to upstream database cluster.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//
//	name: db-mtls
//
// spec:
//
//	host: mydbserver.prod.svc.cluster.local
//	trafficPolicy:
//	  tls:
//	    mode: MUTUAL
//	    clientCertificate: /etc/certs/myclientcert.pem
//	    privateKey: /etc/certs/client_private_key.pem
//	    caCertificates: /etc/certs/rootcacerts.pem
//
// ```
// {{</tab>}}
//
// {{<tab name="v1beta1" category-value="v1beta1">}}
// ```yaml
// apiVersion: networking.istio.io/v1beta1
// kind: DestinationRule
// metadata:
//
//	name: db-mtls
//
// spec:
//
//	host: mydbserver.prod.svc.cluster.local
//	trafficPolicy:
//	  tls:
//	    mode: MUTUAL
//	    clientCertificate: /etc/certs/myclientcert.pem
//	    privateKey: /etc/certs/client_private_key.pem
//	    caCertificates: /etc/certs/rootcacerts.pem
//
// ```
// {{</tab>}}
// {{</tabset>}}
//
// The following rule configures a client to use TLS when talking to a
// foreign service whose domain matches *.foo.com.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//
//	name: tls-foo
//
// spec:
//
//	host: "*.foo.com"
//	trafficPolicy:
//	  tls:
//	    mode: SIMPLE
//
// ```
// {{</tab>}}
//
// {{<tab name="v1beta1" category-value="v1beta1">}}
// ```yaml
// apiVersion: networking.istio.io/v1beta1
// kind: DestinationRule
// metadata:
//
//	name: tls-foo
//
// spec:
//
//	host: "*.foo.com"
//	trafficPolicy:
//	  tls:
//	    mode: SIMPLE
//
// ```
// {{</tab>}}
// {{</tabset>}}
//
// The following rule configures a client to use Istio mutual TLS when talking
// to rating services.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: DestinationRule
// metadata:
//
//	name: ratings-istio-mtls
//
// spec:
//
//	host: ratings.prod.svc.cluster.local
//	trafficPolicy:
//	  tls:
//	    mode: ISTIO_MUTUAL
//
// ```
// {{</tab>}}
//
// {{<tab name="v1beta1" category-value="v1beta1">}}
// ```yaml
// apiVersion: networking.istio.io/v1beta1
// kind: DestinationRule
// metadata:
//
//	name: ratings-istio-mtls
//
// spec:
//
//	host: ratings.prod.svc.cluster.local
//	trafficPolicy:
//	  tls:
//	    mode: ISTIO_MUTUAL
//
// ```
// {{</tab>}}
// {{</tabset>}}
type ClientTLSSettings struct {
	// Indicates whether connections to this port should be secured
	// using TLS. The value of this field determines how TLS is enforced.
	Mode ClientTLSSettingsTLSmode `json:"mode,omitempty"`
	// REQUIRED if mode is `MUTUAL`. The path to the file holding the
	// client-side TLS certificate to use.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	ClientCertificate string `json:"clientCertificate,omitempty"`
	// REQUIRED if mode is `MUTUAL`. The path to the file holding the
	// client's private key.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	PrivateKey string `json:"privateKey,omitempty"`
	// OPTIONAL: The path to the file containing certificate authority
	// certificates to use in verifying a presented server certificate. If
	// omitted, the proxy will not verify the server's certificate.
	// Should be empty if mode is `ISTIO_MUTUAL`.
	CaCertificates string `json:"caCertificates,omitempty"`
	// The name of the secret that holds the TLS certs for the
	// client including the CA certificates. This secret must exist in
	// the namespace of the proxy using the certificates.
	// An Opaque secret should contain the following keys and values:
	// `key: <privateKey>`, `cert: <clientCert>`, `cacert: <CACertificate>`,
	// `crl: <certificateRevocationList>`
	// Here CACertificate is used to verify the server certificate.
	// For mutual TLS, `cacert: <CACertificate>` can be provided in the
	// same secret or a separate secret named `<secret>-cacert`.
	// A TLS secret for client certificates with an additional
	// `ca.crt` key for CA certificates and `ca.crl` key for
	// certificate revocation list(CRL) is also supported.
	// Only one of client certificates and CA certificate
	// or credentialName can be specified.
	//
	// **NOTE:** This field is applicable at sidecars only if
	// `DestinationRule` has a `workloadSelector` specified.
	// Otherwise the field will be applicable only at gateways, and
	// sidecars will continue to use the certificate paths.
	CredentialName string `json:"credentialName,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate. If specified, the proxy will verify that the server
	// certificate's subject alt name matches one of the specified values.
	// If specified, this list overrides the value of subject_alt_names
	// from the ServiceEntry. If unspecified, automatic validation of upstream
	// presented certificate for new upstream connections will be done based on the
	// downstream HTTP host/authority header, provided `VERIFY_CERTIFICATE_AT_CLIENT`
	// and `ENABLE_AUTO_SNI` environmental variables are set to `true`.
	SubjectAltNames []string `json:"subjectAltNames,omitempty"`
	// SNI string to present to the server during TLS handshake.
	// If unspecified, SNI will be automatically set based on downstream HTTP
	// host/authority header for SIMPLE and MUTUAL TLS modes, provided `ENABLE_AUTO_SNI`
	// environmental variable is set to `true`.
	Sni string `json:"sni,omitempty"`
	// `insecureSkipVerify` specifies whether the proxy should skip verifying the
	// CA signature and SAN for the server certificate corresponding to the host.
	// This flag should only be set if global CA signature verification is
	// enabled, `VERIFY_CERTIFICATE_AT_CLIENT` environmental variable is set to `true`,
	// but no verification is desired for a specific host. If enabled with or
	// without `VERIFY_CERTIFICATE_AT_CLIENT` enabled, verification of the CA signature and
	// SAN will be skipped.
	//
	// `insecureSkipVerify` is `false` by default.
	// `VERIFY_CERTIFICATE_AT_CLIENT` is `false` by default in Istio version 1.9 but will
	// be `true` by default in a later version where, going forward, it will be
	// enabled by default.
	InsecureSkipVerify *bool `json:"insecureSkipVerify,omitempty"`
	// OPTIONAL: The path to the file containing the certificate revocation list (CRL)
	// to use in verifying a presented server certificate. `CRL` is a list of certificates
	// that have been revoked by the CA (Certificate Authority) before their scheduled expiration date.
	// If specified, the proxy will verify if the presented certificate is part of the revoked list of certificates.
	// If omitted, the proxy will not verify the certificate against the `crl`.
	CaCrl string `json:"caCrl,omitempty"`
}

// Locality-weighted load balancing allows administrators to control the
// distribution of traffic to endpoints based on the localities of where the
// traffic originates and where it will terminate. These localities are
// specified using arbitrary labels that designate a hierarchy of localities in
// {region}/{zone}/{sub-zone} form. For additional detail refer to
// [Locality Weight](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight)
// The following example shows how to setup locality weights mesh-wide.
//
// Given a mesh with workloads and their service deployed to "us-west/zone1/*"
// and "us-west/zone2/*". This example specifies that when traffic accessing a
// service originates from workloads in "us-west/zone1/*", 80% of the traffic
// will be sent to endpoints in "us-west/zone1/*", i.e the same zone, and the
// remaining 20% will go to endpoints in "us-west/zone2/*". This setup is
// intended to favor routing traffic to endpoints in the same locality.
// A similar setting is specified for traffic originating in "us-west/zone2/*".
//
// ```yaml
//
//	distribute:
//	  - from: us-west/zone1/*
//	    to:
//	      "us-west/zone1/*": 80
//	      "us-west/zone2/*": 20
//	  - from: us-west/zone2/*
//	    to:
//	      "us-west/zone1/*": 20
//	      "us-west/zone2/*": 80
//
// ```
//
// If the goal of the operator is not to distribute load across zones and
// regions but rather to restrict the regionality of failover to meet other
// operational requirements an operator can set a 'failover' policy instead of
// a 'distribute' policy.
//
// The following example sets up a locality failover policy for regions.
// Assume a service resides in zones within us-east, us-west & eu-west
// this example specifies that when endpoints within us-east become unhealthy
// traffic should failover to endpoints in any zone or sub-zone within eu-west
// and similarly us-west should failover to us-east.
//
// ```yaml
//
//	failover:
//	  - from: us-east
//	    to: eu-west
//	  - from: us-west
//	    to: us-east
//
// ```
// Locality load balancing settings.
type LocalityLoadBalancerSetting struct {
	// Optional: only one of distribute, failover or failoverPriority can be set.
	// Explicitly specify loadbalancing weight across different zones and geographical locations.
	// Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight)
	// If empty, the locality weight is set according to the endpoints number within it.
	Distribute []*LocalityLoadBalancerSettingDistribute `json:"distribute,omitempty"`
	// Optional: only one of distribute, failover or failoverPriority can be set.
	// Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy.
	// Should be used together with OutlierDetection to detect unhealthy endpoints.
	// Note: if no OutlierDetection specified, this will not take effect.
	Failover []*LocalityLoadBalancerSettingFailover `json:"failover,omitempty"`
	// failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.
	// This is to support traffic failover across different groups of endpoints.
	// Two kinds of labels can be specified:
	//
	//   - Specify only label keys `[key1, key2, key3]`, istio would compare the label values of client with endpoints.
	//     Suppose there are total N label keys `[key1, key2, key3, ...keyN]` specified:
	//
	//     1. Endpoints matching all N labels with the client proxy have priority P(0) i.e. the highest priority.
	//     2. Endpoints matching the first N-1 labels with the client proxy have priority P(1) i.e. second highest priority.
	//     3. By extension of this logic, endpoints matching only the first label with the client proxy has priority P(N-1) i.e. second lowest priority.
	//     4. All the other endpoints have priority P(N) i.e. lowest priority.
	//
	//   - Specify labels with key and value `[key1=value1, key2=value2, key3=value3]`, istio would compare the labels with endpoints.
	//     Suppose there are total N labels `[key1=value1, key2=value2, key3=value3, ...keyN=valueN]` specified:
	//
	//     1. Endpoints matching all N labels have priority P(0) i.e. the highest priority.
	//     2. Endpoints matching the first N-1 labels have priority P(1) i.e. second highest priority.
	//     3. By extension of this logic, endpoints matching only the first label has priority P(N-1) i.e. second lowest priority.
	//     4. All the other endpoints have priority P(N) i.e. lowest priority.
	//
	// Note: For a label to be considered for match, the previous labels must match, i.e. nth label would be considered matched only if first n-1 labels match.
	//
	// It can be any label specified on both client and server workloads.
	// The following labels which have special semantic meaning are also supported:
	//
	//   - `topology.istio.io/network` is used to match the network metadata of an endpoint, which can be specified by pod/namespace label `topology.istio.io/network`, sidecar env `ISTIO_META_NETWORK` or MeshNetworks.
	//   - `topology.istio.io/cluster` is used to match the clusterID of an endpoint, which can be specified by pod label `topology.istio.io/cluster` or pod env `ISTIO_META_CLUSTER_ID`.
	//   - `topology.kubernetes.io/region` is used to match the region metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/region` or the deprecated label `failure-domain.beta.kubernetes.io/region`.
	//   - `topology.kubernetes.io/zone` is used to match the zone metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/zone` or the deprecated label `failure-domain.beta.kubernetes.io/zone`.
	//   - `topology.istio.io/subzone` is used to match the subzone metadata of an endpoint, which maps to Istio node label `topology.istio.io/subzone`.
	//
	// The below topology config indicates the following priority levels:
	//
	// ```yaml
	// failoverPriority:
	// - "topology.istio.io/network"
	// - "topology.kubernetes.io/region"
	// - "topology.kubernetes.io/zone"
	// - "topology.istio.io/subzone"
	// ```
	//
	// 1. endpoints match same [network, region, zone, subzone] label with the client proxy have the highest priority.
	// 2. endpoints have same [network, region, zone] label but different [subzone] label with the client proxy have the second highest priority.
	// 3. endpoints have same [network, region] label but different [zone] label with the client proxy have the third highest priority.
	// 4. endpoints have same [network] but different [region] labels with the client proxy have the fourth highest priority.
	// 5. all the other endpoints have the same lowest priority.
	//
	// Suppose a service associated endpoints reside in multi clusters, the below example represents:
	// 1. endpoints in `clusterA` and has `version=v1` label have P(0) priority.
	// 2. endpoints not in `clusterA` but has `version=v1` label have P(1) priority.
	// 2. all the other endpoints have P(2) priority.
	//
	// ```yaml
	// failoverPriority:
	// - "version=v1"
	// - "topology.istio.io/cluster=clusterA"
	// ```
	//
	// Optional: only one of distribute, failover or failoverPriority can be set.
	// And it should be used together with `OutlierDetection` to detect unhealthy endpoints, otherwise has no effect.
	FailoverPriority []string `json:"failoverPriority,omitempty"`
	// enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
	// e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
	Enabled *bool `json:"enabled,omitempty"`
}

// TCP keepalive.
type ConnectionPoolSettingsTCPSettingsTcpKeepalive struct {
	// Maximum number of keepalive probes to send without response before
	// deciding the connection is dead. Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 9.)
	Probes uint32 `json:"probes,omitempty"`
	// The time duration a connection needs to be idle before keep-alive
	// probes start being sent. Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 7200s (ie 2 hours.)
	Time *metav1.Duration `json:"time,omitempty"`
	// The time duration between keep-alive probes.
	// Default is to use the OS level configuration
	// (unless overridden, Linux defaults to 75s.)
	Interval *metav1.Duration `json:"interval,omitempty"`
}

// Describes how traffic originating in the 'from' zone or sub-zone is
// distributed over a set of 'to' zones. Syntax for specifying a zone is
// {region}/{zone}/{sub-zone} and terminal wildcards are allowed on any
// segment of the specification. Examples:
//
// `*` - matches all localities
//
// `us-west/*` - all zones and sub-zones within the us-west region
//
// `us-west/zone-1/*` - all sub-zones within us-west/zone-1
type LocalityLoadBalancerSettingDistribute struct {
	// Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.
	From string `json:"from,omitempty"`
	// Map of upstream localities to traffic distribution weights. The sum of
	// all weights should be 100. Any locality not present will
	// receive no traffic.
	To map[string]uint32 `json:"to,omitempty"`
}

// Specify the traffic failover policy across regions. Since zone and sub-zone
// failover is supported by default this only needs to be specified for
// regions when the operator needs to constrain traffic failover so that
// the default behavior of failing over to any endpoint globally does not
// apply. This is useful when failing over traffic across regions would not
// improve service health or may need to be restricted for other reasons
// like regulatory controls.
type LocalityLoadBalancerSettingFailover struct {
	// Originating region.
	From string `json:"from,omitempty"`
	// Destination region the traffic will fail over to when endpoints in
	// the 'from' region becomes unhealthy.
	To string `json:"to,omitempty"`
}

// Describes the retry policy to use when a HTTP request fails. For
// example, the following rule sets the maximum number of retries to 3 when
// calling ratings:v1 service, with a 2s timeout per retry attempt.
// A retry will be attempted if there is a connect-failure, refused_stream
// or when the upstream server responds with Service Unavailable(503).
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: VirtualService
// metadata:
//
//	name: ratings-route
//
// spec:
//
//	hosts:
//	- ratings.prod.svc.cluster.local
//	http:
//	- route:
//	  - destination:
//	      host: ratings.prod.svc.cluster.local
//	      subset: v1
//	  retries:
//	    attempts: 3
//	    perTryTimeout: 2s
//	    retryOn: connect-failure,refused-stream,503
//
// ```
// {{</tab>}}
//
// {{<tab name="v1beta1" category-value="v1beta1">}}
// ```yaml
// apiVersion: networking.istio.io/v1beta1
// kind: VirtualService
// metadata:
//
//	name: ratings-route
//
// spec:
//
//	hosts:
//	- ratings.prod.svc.cluster.local
//	http:
//	- route:
//	  - destination:
//	      host: ratings.prod.svc.cluster.local
//	      subset: v1
//	  retries:
//	    attempts: 3
//	    perTryTimeout: 2s
//	    retryOn: gateway-error,connect-failure,refused-stream
//
// ```
// {{</tab>}}
// {{</tabset>}}
type HTTPRetry struct {
	// Number of retries to be allowed for a given request. The interval
	// between retries will be determined automatically (25ms+). When request
	// `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute)
	// or `per_try_timeout` is configured, the actual number of retries attempted also depends on
	// the specified request `timeout` and `per_try_timeout` values. MUST BE >= 0. If `0`, retries will be disabled.
	// The maximum possible number of requests made will be 1 + `attempts`.
	Attempts int32 `json:"attempts,omitempty"`
	// Timeout per attempt for a given request, including the initial call and any retries. Format: 1h/1m/1s/1ms. MUST BE >=1ms.
	// Default is same value as request
	// `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute),
	// which means no timeout.
	PerTryTimeout *metav1.Duration `json:"perTryTimeout,omitempty"`
	// Specifies the conditions under which retry takes place.
	// One or more policies can be specified using a ‘,’ delimited list.
	// If `retry_on` specifies a valid HTTP status, it will be added to retriable_status_codes retry policy.
	// See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on)
	// and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.
	RetryOn string `json:"retryOn,omitempty"`
	// Flag to specify whether the retries should retry to other localities.
	// See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.
	RetryRemoteLocalities *bool `json:"retryRemoteLocalities,omitempty"`
}

// Network provides information about the endpoints in a routable L3
// network. A single routable L3 network can have one or more service
// registries. Note that the network has no relation to the locality of the
// endpoint. The endpoint locality will be obtained from the service
// registry.
type Network struct {
	// The list of endpoints in the network (obtained through the
	// constituent service registries or from CIDR ranges). All endpoints in
	// the network are directly accessible to one another.
	Endpoints []*NetworkNetworkEndpoints `json:"endpoints,omitempty"`
	// Set of gateways associated with the network.
	Gateways []*NetworkIstioNetworkGateway `json:"gateways,omitempty"`
}

// MeshNetworks (config map) provides information about the set of networks
// inside a mesh and how to route to endpoints in each network. For example
//
// MeshNetworks(file/config map):
//
// ```yaml
// networks:
//
//	network1:
//	  endpoints:
//	  - fromRegistry: registry1 #must match kubeconfig name in Kubernetes secret
//	  - fromCidr: 192.168.100.0/22 #a VM network for example
//	  gateways:
//	  - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
//	    port: 15443
//	    locality: us-east-1a
//	  - address: 192.168.100.1
//	    port: 15443
//	    locality: us-east-1a
//
// ```
type MeshNetworks struct {
	// The set of networks inside this mesh. Each network should
	// have a unique name and information about how to infer the endpoints in
	// the network as well as the gateways associated with the network.
	Networks map[string]*Network `json:"networks,omitempty"`
}

// NetworkEndpoints describes how the network associated with an endpoint
// should be inferred. An endpoint will be assigned to a network based on
// the following rules:
//
// 1. Implicitly: If the registry explicitly provides information about
// the network to which the endpoint belongs to. In some cases, its
// possible to indicate the network associated with the endpoint by
// adding the `ISTIO_META_NETWORK` environment variable to the sidecar.
//
// 2. Explicitly:
//
//	a. By matching the registry name with one of the "fromRegistry"
//	in the mesh config. A "from_registry" can only be assigned to a
//	single network.
//
//	b. By matching the IP against one of the CIDR ranges in a mesh
//	config network. The CIDR ranges must not overlap and be assigned to
//	a single network.
//
// (2) will override (1) if both are present.
// +kubebuilder:validation:XValidation:message="At most one of [fromCidr fromRegistry] should be set",rule="(has(self.fromCidr)?1:0) + (has(self.fromRegistry)?1:0) <= 1"
type NetworkNetworkEndpoints struct {
	// A CIDR range for the set of endpoints in this network. The CIDR
	// ranges for endpoints from different networks must not overlap.
	FromCidr string `json:"fromCidr,omitempty"`

	// Add all endpoints from the specified registry into this network.
	// The names of the registries should correspond to the kubeconfig file name
	// inside the secret that was used to configure the registry (Kubernetes
	// multicluster) or supplied by MCP server.
	FromRegistry string `json:"fromRegistry,omitempty"`
}

// The gateway associated with this network. Traffic from remote networks
// will arrive at the specified gateway:port. All incoming traffic must
// use mTLS.
// +kubebuilder:validation:XValidation:message="At most one of [registryServiceName address] should be set",rule="(has(self.registryServiceName)?1:0) + (has(self.address)?1:0) <= 1"
type NetworkIstioNetworkGateway struct {
	// A fully qualified domain name of the gateway service.  Pilot will
	// lookup the service from the service registries in the network and
	// obtain the endpoint IPs of the gateway from the service
	// registry. Note that while the service name is a fully qualified
	// domain name, it need not be resolvable outside the orchestration
	// platform for the registry. e.g., this could be
	// istio-ingressgateway.istio-system.svc.cluster.local.
	RegistryServiceName string `json:"registryServiceName,omitempty"`

	// IP address or externally resolvable DNS address associated with the gateway.
	Address string `json:"address,omitempty"` // The port associated with the gateway.
	Port    uint32 `json:"port,omitempty"`
	// The locality associated with an explicitly specified gateway (i.e. ip)
	Locality string `json:"locality,omitempty"`
}

// AuthenticationPolicy defines how the proxy is authenticated when it connects to the control plane.
// It can be set for two different scopes, mesh-wide or set on a per-pod basis using the ProxyConfig annotation.
// Mesh policy cannot be INHERIT.
// +kubebuilder:validation:Enum=NONE;MUTUAL_TLS;INHERIT
type AuthenticationPolicy string

const (
	// Do not encrypt proxy to control plane traffic.
	AuthenticationPolicyNone AuthenticationPolicy = "NONE"
	// Proxy to control plane traffic is wrapped into mutual TLS connections.
	AuthenticationPolicyMutualTls AuthenticationPolicy = "MUTUAL_TLS"
	// Use the policy defined by the parent scope. Should not be used for mesh
	// policy.
	AuthenticationPolicyInherit AuthenticationPolicy = "INHERIT"
)

// ForwardClientCertDetails controls how the x-forwarded-client-cert (XFCC)
// header is handled by the gateway proxy.
// See [Envoy XFCC](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto.html#enum-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-forwardclientcertdetails)
// header handling for more details.
// +kubebuilder:validation:Enum=UNDEFINED;SANITIZE;FORWARD_ONLY;APPEND_FORWARD;SANITIZE_SET;ALWAYS_FORWARD_ONLY
type ForwardClientCertDetails string

const (
	// Field is not set
	ForwardClientCertDetailsUndefined ForwardClientCertDetails = "UNDEFINED"
	// Do not send the XFCC header to the next hop. This is the default value.
	ForwardClientCertDetailsSanitize ForwardClientCertDetails = "SANITIZE"
	// When the client connection is mTLS (Mutual TLS), forward the XFCC header
	// in the request.
	ForwardClientCertDetailsForwardOnly ForwardClientCertDetails = "FORWARD_ONLY"
	// When the client connection is mTLS, append the client certificate
	// information to the request’s XFCC header and forward it.
	ForwardClientCertDetailsAppendForward ForwardClientCertDetails = "APPEND_FORWARD"
	// When the client connection is mTLS, reset the XFCC header with the client
	// certificate information and send it to the next hop.
	ForwardClientCertDetailsSanitizeSet ForwardClientCertDetails = "SANITIZE_SET"
	// Always forward the XFCC header in the request, regardless of whether the
	// client connection is mTLS.
	ForwardClientCertDetailsAlwaysForwardOnly ForwardClientCertDetails = "ALWAYS_FORWARD_ONLY"
)

// TraceContext selects the context propagation headers used for
// distributed tracing.
// +kubebuilder:validation:Enum=UNSPECIFIED;W3C_TRACE_CONTEXT;GRPC_BIN;CLOUD_TRACE_CONTEXT;B3
type TracingOpenCensusAgentTraceContext string

const (
	// $hide_from_docs
	// Unspecified context. Should not be used for now, but added to reserve
	// the 0 enum value if TraceContext is used outside of a repeated field.
	TracingOpenCensusAgentTraceContextUnspecified TracingOpenCensusAgentTraceContext = "UNSPECIFIED"
	// Use W3C Trace Context propagation using the `traceparent` HTTP header.
	// See the
	// [Trace Context documentation](https://www.w3.org/TR/trace-context/) for details.
	TracingOpenCensusAgentTraceContextW3cTraceContext TracingOpenCensusAgentTraceContext = "W3C_TRACE_CONTEXT"
	// Use gRPC binary context propagation using the `grpc-trace-bin` http header.
	TracingOpenCensusAgentTraceContextGrpcBin TracingOpenCensusAgentTraceContext = "GRPC_BIN"
	// Use Cloud Trace context propagation using the
	// `X-Cloud-Trace-Context` http header.
	TracingOpenCensusAgentTraceContextCloudTraceContext TracingOpenCensusAgentTraceContext = "CLOUD_TRACE_CONTEXT"
	// Use multi-header B3 context propagation using the `X-B3-TraceId`,
	// `X-B3-SpanId`, and `X-B3-Sampled` HTTP headers. See
	// [B3 header propagation README](https://github.com/openzipkin/b3-propagation)
	// for details.
	TracingOpenCensusAgentTraceContextB3 TracingOpenCensusAgentTraceContext = "B3"
)

// Allows specification of various Istio-supported naming schemes for the
// Envoy `service_cluster` value. The `servce_cluster` value is primarily used
// by Envoys to provide service names for tracing spans.
// +kubebuilder:validation:Enum=APP_LABEL_AND_NAMESPACE;CANONICAL_NAME_ONLY;CANONICAL_NAME_AND_NAMESPACE
type ProxyConfigTracingServiceName string

const (
	// Default scheme. Uses the `app` label and workload namespace to construct
	// a cluster name. If the `app` label does not exist `istio-proxy` is used.
	ProxyConfigTracingServiceNameAppLabelAndNamespace ProxyConfigTracingServiceName = "APP_LABEL_AND_NAMESPACE"
	// Uses the canonical name for a workload (*excluding namespace*).
	ProxyConfigTracingServiceNameCanonicalNameOnly ProxyConfigTracingServiceName = "CANONICAL_NAME_ONLY"
	// Uses the canonical name and namespace for a workload.
	ProxyConfigTracingServiceNameCanonicalNameAndNamespace ProxyConfigTracingServiceName = "CANONICAL_NAME_AND_NAMESPACE"
)

// The mode used to redirect inbound traffic to Envoy.
// This setting has no effect on outbound traffic: iptables `REDIRECT` is always used for
// outbound connections.
// +kubebuilder:validation:Enum=REDIRECT;TPROXY;NONE
type ProxyConfigInboundInterceptionMode string

const (
	// The `REDIRECT` mode uses iptables `REDIRECT` to `NAT` and redirect to Envoy. This mode loses
	// source IP addresses during redirection. This is the default redirection mode.
	ProxyConfigInboundInterceptionModeRedirect ProxyConfigInboundInterceptionMode = "REDIRECT"
	// The `TPROXY` mode uses iptables `TPROXY` to redirect to Envoy. This mode preserves both the
	// source and destination IP addresses and ports, so that they can be used for advanced
	// filtering and manipulation. This mode also configures the sidecar to run with the
	// `CAP_NET_ADMIN` capability, which is required to use `TPROXY`.
	ProxyConfigInboundInterceptionModeTproxy ProxyConfigInboundInterceptionMode = "TPROXY"
	// The `NONE` mode does not configure redirect to Envoy at all. This is an advanced
	// configuration that typically requires changes to user applications.
	ProxyConfigInboundInterceptionModeNone ProxyConfigInboundInterceptionMode = "NONE"
)

// +kubebuilder:validation:Enum=UNDEFINED;IN_MESH
type ProxyConfigProxyHeadersMetadataExchangeMode string

const (
	// Existing Istio behavior for the metadata exchange headers is unchanged.
	ProxyConfigProxyHeadersMetadataExchangeModeUndefined ProxyConfigProxyHeadersMetadataExchangeMode = "UNDEFINED"
	// Only append the istio metadata exchange headers for services considered in-mesh.
	// Traffic is considered in-mesh if it is secured with Istio mutual TLS. This means that `MESH_EXTERNAL` services, unmatched passthrough traffic, and requests to workloads without Istio enabled will be considered out of mesh.
	ProxyConfigProxyHeadersMetadataExchangeModeInMesh ProxyConfigProxyHeadersMetadataExchangeMode = "IN_MESH"
)

// Tracing defines configuration for the tracing performed by Envoy instances.
// +kubebuilder:validation:XValidation:message="At most one of [zipkin lightstep datadog stackdriver openCensusAgent] should be set",rule="(has(self.zipkin)?1:0) + (has(self.lightstep)?1:0) + (has(self.datadog)?1:0) + (has(self.stackdriver)?1:0) + (has(self.openCensusAgent)?1:0) <= 1"
type Tracing struct {
	// Use a Zipkin tracer.
	Zipkin *TracingZipkin `json:"zipkin,omitempty"`

	// Use a Lightstep tracer.
	// NOTE: For Istio 1.15+, this configuration option will result
	// in using OpenTelemetry-based Lightstep integration.
	Lightstep *TracingLightstep `json:"lightstep,omitempty"`

	// Use a Datadog tracer.
	Datadog *TracingDatadog `json:"datadog,omitempty"`

	// Use a Stackdriver tracer.
	Stackdriver *TracingStackdriver `json:"stackdriver,omitempty"`

	// Use an OpenCensus tracer exporting to an OpenCensus agent.
	OpenCensusAgent *TracingOpenCensusAgent `json:"openCensusAgent,omitempty"` // Configures the custom tags to be added to active span by all proxies (i.e. sidecars
	// and gateways).
	// The key represents the name of the tag.
	// Ex:
	// ```yaml
	// custom_tags:
	//
	//	new_tag_name:
	//	  header:
	//	    name: custom-http-header-name
	//	    default_value: defaulted-value-from-custom-header
	//
	// ```
	// $hide_from_docs
	CustomTags map[string]*TracingCustomTag `json:"customTags,omitempty"`
	// Configures the maximum length of the request path to extract and include in the
	// HttpUrl tag. Used to truncate length request paths to meet the needs of tracing
	// backend. If not set, then a length of 256 will be used.
	// $hide_from_docs
	MaxPathTagLength uint32 `json:"maxPathTagLength,omitempty"`
	// The percentage of requests (0.0 - 100.0) that will be randomly selected for trace generation,
	// if not requested by the client or not forced. Default is 1.0.
	Sampling float64 `json:"sampling,omitempty"`
	// Use the tls_settings to specify the tls mode to use. If the remote tracing service
	// uses Istio mutual TLS and shares the root CA with Pilot, specify the TLS
	// mode as `ISTIO_MUTUAL`.
	TlsSettings *ClientTLSSettings `json:"tlsSettings,omitempty"`
}

// SDS defines secret discovery service(SDS) configuration to be used by the proxy.
// For workload, its values are set in sidecar injector(passed as arguments to istio-proxy container).
// For pilot/mixer, it's passed as arguments to istio-proxy container in pilot/mixer deployment yaml files directly.
// $hide_from_docs
type SDS struct {
	// True if SDS is enabled.
	Enabled bool `json:"enabled,omitempty"`
	// Path of k8s service account JWT path.
	K8SSaJwtPath string `json:"k8sSaJwtPath,omitempty"`
}

// Topology describes the configuration for relative location of a proxy with
// respect to intermediate trusted proxies and the client. These settings
// control how the client attributes are retrieved from the incoming traffic by
// the gateway proxy and propagated to the upstream services in the cluster.
type Topology struct {
	// Number of trusted proxies deployed in front of the Istio gateway proxy.
	// When this option is set to value N greater than zero, the trusted client
	// address is assumed to be the Nth address from the right end of the
	// X-Forwarded-For (XFF) header from the incoming request. If the
	// X-Forwarded-For (XFF) header is missing or has fewer than N addresses, the
	// gateway proxy falls back to using the immediate downstream connection's
	// source address as the trusted client address.
	// Note that the gateway proxy will append the downstream connection's source
	// address to the X-Forwarded-For (XFF) address and set the
	// X-Envoy-External-Address header to the trusted client address before
	// forwarding it to the upstream services in the cluster.
	// The default value of num_trusted_proxies is 0.
	// See [Envoy XFF](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#config-http-conn-man-headers-x-forwarded-for)
	// header handling for more details.
	NumTrustedProxies uint32 `json:"numTrustedProxies,omitempty"`
	// Configures how the gateway proxy handles x-forwarded-client-cert (XFCC)
	// header in the incoming request.
	ForwardClientCertDetails ForwardClientCertDetails `json:"forwardClientCertDetails,omitempty"`
	// Enables [PROXY protocol](http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt) for
	// downstream connections on a gateway.
	ProxyProtocol *TopologyProxyProtocolConfiguration `json:"proxyProtocol,omitempty"`
}

// PrivateKeyProvider defines private key configuration for gateways and sidecars. This can be configured
// mesh wide or individual per-workload basis.
// +kubebuilder:validation:XValidation:message="At most one of [cryptomb qat] should be set",rule="(has(self.cryptomb)?1:0) + (has(self.qat)?1:0) <= 1"
type PrivateKeyProvider struct {
	// Use CryptoMb private key provider
	Cryptomb *PrivateKeyProviderCryptoMb `json:"cryptomb,omitempty"`

	// Use QAT private key provider
	Qat *PrivateKeyProviderQAT `json:"qat,omitempty"`
}

// ProxyConfig defines variables for individual Envoy instances. This can be configured on a per-workload basis
// as well as by the mesh-wide defaults.
// To set the mesh wide defaults, configure the `defaultConfig` section of `meshConfig`. For example:
//
// ```
// meshConfig:
//
//	defaultConfig:
//	  discoveryAddress: istiod:15012
//
// ```
//
// This can also be configured on a per-workload basis by configuring the `proxy.istio.io/config` annotation on the pod. For example:
//
// ```
// annotations:
//
//	proxy.istio.io/config: |
//	  discoveryAddress: istiod:15012
//
// ```
//
// If both are configured, the two are merged with per field semantics; the field set in annotation will fully replace the field from mesh config defaults.
// This is different than a deep merge provided by protobuf.
// For example, `"tracing": { "sampling": 5 }` would completely override a setting configuring a tracing provider
// such as `"tracing": { "zipkin": { "address": "..." } }`.
//
// Note: fields in ProxyConfig are not dynamically configured; changes will require restart of workloads to take effect.
// +kubebuilder:validation:XValidation:message="At most one of [serviceCluster tracingServiceName] should be set",rule="(has(self.serviceCluster)?1:0) + (has(self.tracingServiceName)?1:0) <= 1"
type MeshConfigProxyConfig struct {
	// Path to the generated configuration file directory.
	// Proxy agent generates the actual configuration and stores it in this directory.
	ConfigPath string `json:"configPath,omitempty"`
	// Path to the proxy binary
	BinaryPath string `json:"binaryPath,omitempty"`

	// Service cluster defines the name for the `service_cluster` that is
	// shared by all Envoy instances. This setting corresponds to
	// `--service-cluster` flag in Envoy.  In a typical Envoy deployment, the
	// `service-cluster` flag is used to identify the caller, for
	// source-based routing scenarios.
	//
	// Since Istio does not assign a local `service/service` version to each
	// Envoy instance, the name is same for all of them.  However, the
	// source/caller's identity (e.g., IP address) is encoded in the
	// `--service-node` flag when launching Envoy.  When the RDS service
	// receives API calls from Envoy, it uses the value of the `service-node`
	// flag to compute routes that are relative to the service instances
	// located at that IP address.
	ServiceCluster string `json:"serviceCluster,omitempty"`

	// Used by Envoy proxies to assign the values for the service names in trace
	// spans.
	TracingServiceName ProxyConfigTracingServiceName `json:"tracingServiceName,omitempty"` // The time in seconds that Envoy will drain connections during a hot
	// restart. MUST be >=1s (e.g., _1s/1m/1h_)
	// Default drain duration is `45s`.
	DrainDuration *metav1.Duration `json:"drainDuration,omitempty"`
	// Address of the discovery service exposing xDS with mTLS connection.
	// The inject configuration may override this value.
	DiscoveryAddress string `json:"discoveryAddress,omitempty"`
	// $hide_from_docs
	//
	// Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.
	DiscoveryRefreshDelay *metav1.Duration `json:"discoveryRefreshDelay,omitempty"`
	// Address of the Zipkin service (e.g. _zipkin:9411_).
	// DEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.
	//
	// Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.
	ZipkinAddress string `json:"zipkinAddress,omitempty"`
	// IP Address and Port of a statsd UDP listener (e.g. `10.75.241.127:9125`).
	StatsdUdpAddress string `json:"statsdUdpAddress,omitempty"`
	// $hide_from_docs
	//
	// Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.
	EnvoyMetricsServiceAddress string `json:"envoyMetricsServiceAddress,omitempty"`
	// Port on which Envoy should listen for administrative commands.
	// Default port is `15000`.
	ProxyAdminPort int32 `json:"proxyAdminPort,omitempty"`
	// $hide_from_docs
	//
	// Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.
	AvailabilityZone string `json:"availabilityZone,omitempty"`
	// AuthenticationPolicy defines how the proxy is authenticated when it connects to the control plane.
	// Default is set to `MUTUAL_TLS`.
	ControlPlaneAuthPolicy AuthenticationPolicy `json:"controlPlaneAuthPolicy,omitempty"`
	// File path of custom proxy configuration, currently used by proxies
	// in front of Mixer and Pilot.
	CustomConfigFile string `json:"customConfigFile,omitempty"`
	// Maximum length of name field in Envoy's metrics. The length of the name field
	// is determined by the length of a name field in a service and the set of labels that
	// comprise a particular version of the service. The default value is set to 189 characters.
	// Envoy's internal metrics take up 67 characters, for a total of 256 character name per metric.
	// Increase the value of this field if you find that the metrics from Envoys are truncated.
	StatNameLength int32 `json:"statNameLength,omitempty"`
	// The number of worker threads to run.
	// If unset, this will be automatically determined based on CPU requests/limits.
	// If set to 0, all cores on the machine will be used.
	// Default is 2 worker threads.
	Concurrency *int32 `json:"concurrency,omitempty"`
	// Path to the proxy bootstrap template file
	ProxyBootstrapTemplatePath string `json:"proxyBootstrapTemplatePath,omitempty"`
	// The mode used to redirect inbound traffic to Envoy.
	InterceptionMode ProxyConfigInboundInterceptionMode `json:"interceptionMode,omitempty"`
	// Tracing configuration to be used by the proxy.
	Tracing *Tracing `json:"tracing,omitempty"`
	// Secret Discovery Service(SDS) configuration to be used by the proxy.
	// $hide_from_docs
	//
	// Deprecated: Marked as deprecated in mesh/v1alpha1/proxy.proto.
	Sds *SDS `json:"sds,omitempty"`
	// Address of the service to which access logs from Envoys should be
	// sent. (e.g. `accesslog-service:15000`). See [Access Log
	// Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/accesslog/v2/als.proto)
	// for details about Envoy's gRPC Access Log Service API.
	EnvoyAccessLogService *RemoteService `json:"envoyAccessLogService,omitempty"`
	// Address of the Envoy Metrics Service implementation (e.g. `metrics-service:15000`).
	// See [Metric Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/metrics/v2/metrics_service.proto)
	// for details about Envoy's Metrics Service API.
	EnvoyMetricsService *RemoteService `json:"envoyMetricsService,omitempty"`
	// Additional environment variables for the proxy.
	// Names starting with `ISTIO_META_` will be included in the generated bootstrap and sent to the XDS server.
	ProxyMetadata map[string]string `json:"proxyMetadata,omitempty"`
	// Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping.
	// This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.
	RuntimeValues map[string]string `json:"runtimeValues,omitempty"`
	// Port on which the agent should listen for administrative commands such as readiness probe.
	// Default is set to port `15020`.
	StatusPort int32 `json:"statusPort,omitempty"`
	// An additional list of tags to extract from the in-proxy Istio telemetry. These extra tags can be
	// added by configuring the telemetry extension. Each additional tag needs to be present in this list.
	// Extra tags emitted by the telemetry extensions must be listed here so that they can be processed
	// and exposed as Prometheus metrics.
	// Deprecated: `istio.stats` is a native filter now, this field is no longer needed.
	ExtraStatTags []string `json:"extraStatTags,omitempty"`
	// Topology encapsulates the configuration which describes where the proxy is
	// located i.e. behind a (or N) trusted proxy (proxies) or directly exposed
	// to the internet. This configuration only effects gateways and is applied
	// to all the gateways in the cluster unless overridden via annotations of the
	// gateway workloads.
	GatewayTopology *Topology `json:"gatewayTopology,omitempty"`
	// The amount of time allowed for connections to complete on proxy shutdown.
	// On receiving `SIGTERM` or `SIGINT`, `istio-agent` tells the active Envoy to start draining,
	// preventing any new connections and allowing existing connections to complete. It then
	// sleeps for the `termination_drain_duration` and then kills any remaining active Envoy processes.
	// If not set, a default of `5s` will be applied.
	TerminationDrainDuration *metav1.Duration `json:"terminationDrainDuration,omitempty"`
	// The unique identifier for the [service mesh](https://istio.io/docs/reference/glossary/#service-mesh)
	// All control planes running in the same service mesh should specify the same mesh ID.
	// Mesh ID is used to label telemetry reports for cases where telemetry from multiple meshes is mixed together.
	MeshId string `json:"meshId,omitempty"`
	// VM Health Checking readiness probe. This health check config exactly mirrors the
	// kubernetes readiness probe configuration both in schema and logic.
	// Only one health check method of 3 can be set at a time.
	ReadinessProbe *k8sv1.Probe `json:"readinessProbe,omitempty"`
	// Proxy stats matcher defines configuration for reporting custom Envoy stats.
	// To reduce memory and CPU overhead from Envoy stats system, Istio proxies by
	// default create and expose only a subset of Envoy stats. This option is to
	// control creation of additional Envoy stats with prefix, suffix, and regex
	// expressions match on the name of the stats. This replaces the stats
	// inclusion annotations
	// (`sidecar.istio.io/statsInclusionPrefixes`,
	// `sidecar.istio.io/statsInclusionRegexps`, and
	// `sidecar.istio.io/statsInclusionSuffixes`). For example, to enable stats
	// for circuit breakers, request retries, upstream connections, and request timeouts,
	// you can specify stats matcher as follows:
	// ```yaml
	// proxyStatsMatcher:
	//
	//	inclusionRegexps:
	//	  - .*outlier_detection.*
	//	  - .*upstream_rq_retry.*
	//	  - .*upstream_cx_.*
	//	inclusionSuffixes:
	//	  - upstream_rq_timeout
	//
	// ```
	// Note including more Envoy stats might increase number of time series
	// collected by prometheus significantly. Care needs to be taken on Prometheus
	// resource provision and configuration to reduce cardinality.
	ProxyStatsMatcher *ProxyConfigProxyStatsMatcher `json:"proxyStatsMatcher,omitempty"`
	// Boolean flag for enabling/disabling the holdApplicationUntilProxyStarts behavior.
	// This feature adds hooks to delay application startup until the pod proxy
	// is ready to accept traffic, mitigating some startup race conditions.
	// Default value is 'false'.
	HoldApplicationUntilProxyStarts *bool `json:"holdApplicationUntilProxyStarts,omitempty"`
	// The PEM data of the extra root certificates for workload-to-workload communication.
	// This includes the certificates defined in MeshConfig and any other certificates that Istiod uses as CA.
	// The plugin certificates (the 'cacerts' secret), self-signed certificates (the 'istio-ca-secret' secret)
	// are added automatically by Istiod.
	CaCertificatesPem []string `json:"caCertificatesPem,omitempty"`
	// Specifies the details of the proxy image.
	Image *ProxyImage `json:"image,omitempty"`
	// Specifies the details of the Private Key Provider configuration for gateway and sidecar proxies.
	PrivateKeyProvider *PrivateKeyProvider `json:"privateKeyProvider,omitempty"`
	// Define the set of headers to add/modify for HTTP request/responses.
	//
	// To enable an optional header, simply set the field. If no specific configuration is required, an empty object (`{}`) will enable it.
	// Note: currently all headers are enabled by default.
	//
	// Below shows an example of customizing the `server` header and disabling the `X-Envoy-Attempt-Count` header:
	//
	// ```yaml
	// proxyHeaders:
	//
	//	server:
	//	  value: "my-custom-server"
	//	requestId: {} // Explicitly enable Request IDs. As this is the default, this has no effect.
	//	attemptCount:
	//	  disabled: true
	//
	// ```
	//
	// Some headers are enabled by default, and require explicitly disabling. See below for an example of disabling all default-enabled headers:
	//
	// ```yaml
	// proxyHeaders:
	//
	//	forwardedClientCert: SANITIZE
	//	server:
	//	  disabled: true
	//	requestId:
	//	  disabled: true
	//	attemptCount:
	//	  disabled: true
	//	envoyDebugHeaders:
	//	  disabled: true
	//	metadataExchangeHeaders:
	//	  mode: IN_MESH
	//
	// ```
	ProxyHeaders *ProxyConfigProxyHeaders `json:"proxyHeaders,omitempty"`
}

type RemoteService struct {
	// Address of a remove service used for various purposes (access log
	// receiver, metrics receiver, etc.). Can be IP address or a fully
	// qualified DNS name.
	Address string `json:"address,omitempty"`
	// Use the `tls_settings` to specify the tls mode to use. If the remote service
	// uses Istio mutual TLS and shares the root CA with Pilot, specify the TLS
	// mode as `ISTIO_MUTUAL`.
	TlsSettings *ClientTLSSettings `json:"tlsSettings,omitempty"`
	// If set then set `SO_KEEPALIVE` on the socket to enable TCP Keepalives.
	TcpKeepalive *ConnectionPoolSettingsTCPSettingsTcpKeepalive `json:"tcpKeepalive,omitempty"`
}

// Zipkin defines configuration for a Zipkin tracer.
type TracingZipkin struct {
	// Address of the Zipkin service (e.g. _zipkin:9411_).
	Address string `json:"address,omitempty"`
}

// $hide_from_docs
// Defines configuration for a Lightstep tracer.
type TracingLightstep struct {
	// Address of the Lightstep Satellite pool.
	Address string `json:"address,omitempty"`
	// The Lightstep access token.
	AccessToken string `json:"accessToken,omitempty"`
}

// Datadog defines configuration for a Datadog tracer.
type TracingDatadog struct {
	// Address of the Datadog Agent.
	Address string `json:"address,omitempty"`
}

// Stackdriver defines configuration for a Stackdriver tracer.
// See [Envoy's OpenCensus trace configuration](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opencensus.proto)
// and
// [OpenCensus trace config](https://github.com/census-instrumentation/opencensus-proto/blob/master/src/opencensus/proto/trace/v1/trace_config.proto) for details.
type TracingStackdriver struct {
	// debug enables trace output to stdout.
	// $hide_from_docs
	Debug bool `json:"debug,omitempty"`
	// The global default max number of attributes per span.
	// default is 200.
	// $hide_from_docs
	MaxNumberOfAttributes *int64 `json:"maxNumberOfAttributes,omitempty"`
	// The global default max number of annotation events per span.
	// default is 200.
	// $hide_from_docs
	MaxNumberOfAnnotations *int64 `json:"maxNumberOfAnnotations,omitempty"`
	// The global default max number of message events per span.
	// default is 200.
	// $hide_from_docs
	MaxNumberOfMessageEvents *int64 `json:"maxNumberOfMessageEvents,omitempty"`
}

// OpenCensusAgent defines configuration for an OpenCensus tracer writing to
// an OpenCensus agent backend. See
// [Envoy's OpenCensus trace configuration](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/opencensus.proto)
// and
// [OpenCensus trace config](https://github.com/census-instrumentation/opencensus-proto/blob/master/src/opencensus/proto/trace/v1/trace_config.proto)
// for details.
type TracingOpenCensusAgent struct {
	// gRPC address for the OpenCensus agent (e.g. dns://authority/host:port or
	// unix:path). See [gRPC naming
	// docs](https://github.com/grpc/grpc/blob/master/doc/naming.md) for
	// details.
	Address string `json:"address,omitempty"`
	// Specifies the set of context propagation headers used for distributed
	// tracing. Default is `["W3C_TRACE_CONTEXT"]`. If multiple values are specified,
	// the proxy will attempt to read each header for each request and will
	// write all headers.
	Context []TracingOpenCensusAgentTraceContext `json:"context,omitempty"`
}

// Configure custom tags that will be added to any active span.
// Tags can be generated via literals, environment variables or an incoming request header.
// $hide_from_docs
// +kubebuilder:validation:XValidation:message="At most one of [literal environment header] should be set",rule="(has(self.literal)?1:0) + (has(self.environment)?1:0) + (has(self.header)?1:0) <= 1"
type TracingCustomTag struct {
	// The custom tag's value is the specified literal.
	Literal *TracingLiteral `json:"literal,omitempty"`

	// The custom tag's value should be populated from an environmental
	// variable
	Environment *TracingEnvironment `json:"environment,omitempty"`

	// The custom tag's value is populated by an http header from
	// an incoming request.
	Header *TracingRequestHeader `json:"header,omitempty"`
}

// Literal type represents a static value.
// $hide_from_docs
type TracingLiteral struct {
	// Static literal value used to populate the tag value.
	Value string `json:"value,omitempty"`
}

// Environment is the proxy's environment variable to be used for populating the custom span tag.
// $hide_from_docs
type TracingEnvironment struct {
	// Name of the environment variable used to populate the tag's value
	Name string `json:"name,omitempty"`
	// When the environment variable is not found,
	// the tag's value will be populated with this default value if specified,
	// otherwise the tag will not be populated.
	DefaultValue string `json:"defaultValue,omitempty"`
}

// RequestHeader is the HTTP request header which will be used to populate the span tag.
// A default value can be configured if the header does not exist.
// $hide_from_docs
type TracingRequestHeader struct {
	// HTTP header name used to obtain the value from to populate the tag value.
	Name string `json:"name,omitempty"`
	// Default value to be used for the tag when the named HTTP header does not exist.
	// The tag will be skipped if no default value is provided.
	DefaultValue string `json:"defaultValue,omitempty"`
}

// PROXY protocol configuration.
type TopologyProxyProtocolConfiguration struct {
}

// CryptoMb PrivateKeyProvider configuration
type PrivateKeyProviderCryptoMb struct {
	// How long to wait until the per-thread processing queue should be processed. If the processing queue
	// gets full (eight sign or decrypt requests are received) it is processed immediately.
	// However, if the queue is not filled before the delay has expired, the requests already in the queue
	// are processed, even if the queue is not full.
	// In effect, this value controls the balance between latency and throughput.
	// The duration needs to be set to a value greater than or equal to 1 millisecond.
	PollDelay *metav1.Duration `json:"pollDelay,omitempty"`
	// If the private key provider isn’t available (eg. the required hardware capability doesn’t existed)
	// Envoy will fallback to the BoringSSL default implementation when the fallback is true.
	// The default value is false.
	Fallback *bool `json:"fallback,omitempty"`
}

// QAT (QuickAssist Technology) PrivateKeyProvider configuration
type PrivateKeyProviderQAT struct {
	// How long to wait before polling the hardware accelerator after a request has been submitted there.
	// Having a small value leads to quicker answers from the hardware but causes more polling loop spins,
	// leading to potentially larger CPU usage.
	// The duration needs to be set to a value greater than or equal to 1 millisecond.
	PollDelay *metav1.Duration `json:"pollDelay,omitempty"`
	// If the private key provider isn’t available (eg. the required hardware capability doesn’t existed)
	// Envoy will fallback to the BoringSSL default implementation when the fallback is true.
	// The default value is false.
	Fallback *bool `json:"fallback,omitempty"`
}

// Proxy stats name matchers for stats creation. Note this is in addition to
// the minimum Envoy stats that Istio generates by default.
type ProxyConfigProxyStatsMatcher struct {
	// Proxy stats name prefix matcher for inclusion.
	InclusionPrefixes []string `json:"inclusionPrefixes,omitempty"`
	// Proxy stats name suffix matcher for inclusion.
	InclusionSuffixes []string `json:"inclusionSuffixes,omitempty"`
	// Proxy stats name regexps matcher for inclusion.
	InclusionRegexps []string `json:"inclusionRegexps,omitempty"`
}

type ProxyConfigProxyHeaders struct {
	// Controls the `X-Forwarded-Client-Cert` header for inbound sidecar requests. To set this on gateways, use the `Topology` setting.
	// To disable the header, configure either `SANITIZE` (to always remove the header, if present) or `FORWARD_ONLY` (to leave the header as-is).
	// By default, `APPEND_FORWARD` will be used.
	ForwardedClientCert ForwardClientCertDetails `json:"forwardedClientCert,omitempty"`
	// Controls the `X-Request-Id` header. If enabled, a request ID is generated for each request if one is not already set.
	// This applies to all types of traffic (inbound, outbound, and gateways).
	// If disabled, no request ID will be generate for the request. If it is already present, it will be preserved.
	// Warning: request IDs are a critical component to mesh tracing and logging, so disabling this is not recommended.
	// This header is enabled by default if not configured.
	RequestId *ProxyConfigProxyHeadersRequestId `json:"requestId,omitempty"`
	// Controls the `server` header. If enabled, the `Server: istio-envoy` header is set in response headers for inbound traffic (including gateways).
	// If disabled, the `Server` header is not modified. If it is already present, it will be preserved.
	Server *ProxyConfigProxyHeadersServer `json:"server,omitempty"`
	// Controls the `X-Envoy-Attempt-Count` header.
	// If enabled, this header will be added on outbound request headers (including gateways) that have retries configured.
	// If disabled, this header will not be set. If it is already present, it will be preserved.
	// This header is enabled by default if not configured.
	AttemptCount *ProxyConfigProxyHeadersAttemptCount `json:"attemptCount,omitempty"`
	// Controls various `X-Envoy-*` headers, such as `X-Envoy-Overloaded` and `X-Envoy-Upstream-Service-Time. If enabled,
	// these headers will be included.
	// If disabled, these headers will not be set. If they are already present, they will be preserved.
	// See the [Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/router/v3/router.proto#envoy-v3-api-field-extensions-filters-http-router-v3-router-suppress-envoy-headers) for more details.
	// These headers are enabled by default if not configured.
	EnvoyDebugHeaders *ProxyConfigProxyHeadersEnvoyDebugHeaders `json:"envoyDebugHeaders,omitempty"`
	// Controls Istio metadata exchange headers `X-Envoy-Peer-Metadata` and `X-Envoy-Peer-Metadata-Id`.
	// By default, the behavior is unspecified.
	// If IN_MESH, these headers will not be appended to outbound requests from sidecars to services not in-mesh.
	MetadataExchangeHeaders *ProxyConfigProxyHeadersMetadataExchangeHeaders `json:"metadataExchangeHeaders,omitempty"`
}

type ProxyConfigProxyHeadersServer struct {
	Disabled *bool `json:"disabled,omitempty"`
	// If set, and the server header is enabled, this value will be set as the server header. By default, `istio-envoy` will be used.
	Value string `json:"value,omitempty"`
}

type ProxyConfigProxyHeadersRequestId struct {
	Disabled *bool `json:"disabled,omitempty"`
}

type ProxyConfigProxyHeadersAttemptCount struct {
	Disabled *bool `json:"disabled,omitempty"`
}

type ProxyConfigProxyHeadersEnvoyDebugHeaders struct {
	Disabled *bool `json:"disabled,omitempty"`
}

type ProxyConfigProxyHeadersMetadataExchangeHeaders struct {
	Mode ProxyConfigProxyHeadersMetadataExchangeMode `json:"mode,omitempty"`
}

// The following values are used to construct proxy image url.
// format: `${hub}/${image_name}/${tag}-${image_type}`,
// example: `docker.io/istio/proxyv2:1.11.1` or `docker.io/istio/proxyv2:1.11.1-distroless`.
// This information was previously part of the Values API.
type ProxyImage struct {
	// The image type of the image.
	// Istio publishes default, debug, and distroless images.
	// Other values are allowed if those image types (example: centos) are published to the specified hub.
	// supported values: default, debug, distroless.
	ImageType string `json:"imageType,omitempty"`
}

// WorkloadMode allows selection of the role of the underlying workload in
// network traffic. A workload is considered as acting as a SERVER if it is
// the destination of the traffic (that is, traffic direction, from the
// perspective of the workload is *inbound*). If the workload is the source of
// the network traffic, it is considered to be in CLIENT mode (traffic is
// *outbound* from the workload).
// +kubebuilder:validation:Enum=UNDEFINED;CLIENT;SERVER;CLIENT_AND_SERVER
type WorkloadMode string

const (
	// Default value, which will be interpreted by its own usage.
	WorkloadModeUndefined WorkloadMode = "UNDEFINED"
	// Selects for scenarios when the workload is the
	// source of the network traffic. In addition,
	// if the workload is a gateway, selects this.
	WorkloadModeClient WorkloadMode = "CLIENT"
	// Selects for scenarios when the workload is the
	// destination of the network traffic.
	WorkloadModeServer WorkloadMode = "SERVER"
	// Selects for scenarios when the workload is either the
	// source or destination of the network traffic.
	WorkloadModeClientAndServer WorkloadMode = "CLIENT_AND_SERVER"
)

// WorkloadSelector specifies the criteria used to determine if a policy can be applied
// to a proxy. The matching criteria includes the metadata associated with a proxy,
// workload instance info such as labels attached to the pod/VM, or any other info
// that the proxy provides to Istio during the initial handshake. If multiple conditions are
// specified, all conditions need to match in order for the workload instance to be
// selected. Currently, only label based selection mechanism is supported.
type WorkloadSelector struct {
	// One or more labels that indicate a specific set of pods/VMs
	// on which a policy should be applied. The scope of label search is restricted to
	// the configuration namespace in which the resource is present.
	MatchLabels map[string]string `json:"matchLabels,omitempty"`
}

// PortSelector is the criteria for specifying if a policy can be applied to
// a listener having a specific port.
type PortSelector struct {
	// Port number
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=65535
	Number uint32 `json:"number,omitempty"`
}

// PolicyTargetReference format as defined by [GEP-713](https://gateway-api.sigs.k8s.io/geps/gep-713/#policy-targetref-api).
//
// PolicyTargetReferences specifies the targeted resource which the policy
// can be applied to. It must only target a single resource at a time, but it
// can be used to target larger resources such as Gateways that may apply to
// multiple child resources. The PolicyTargetReference will be used instead of
// a WorkloadSelector in the RequestAuthentication, AuthorizationPolicy,
// Telemetry, and WasmPlugin CRDs to target a Kubernetes Gateway.
//
// The following is an example of an AuthorizationPolicy bound to a waypoint proxy using
// a PolicyTargetReference. The example sets `action` to `DENY` to create a deny policy.
// It denies all the requests with `POST` method on port `8080` directed through the
// `waypoint` Gateway in the `foo` namespace.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1" category-value="v1">}}
// ```yaml
// apiVersion: security.istio.io/v1
// kind: AuthorizationPolicy
// metadata:
//
//	name: httpbin
//	namespace: foo
//
// spec:
//
//	targetRef:
//	  name: waypoint
//	  kind: Gateway
//	  group: gateway.networking.k8s.io
//	action: DENY
//	rules:
//	- to:
//	  - operation:
//	      methods: ["POST"]
//	      ports: ["8080"]
//
// ```
// {{</tab>}}
// {{</tabset>}}
type PolicyTargetReference struct {
	// group is the group of the target resource.
	Group string `json:"group,omitempty"`
	// kind is kind of the target resource.
	Kind string `json:"kind,omitempty"`
	// name is the name of the target resource.
	Name string `json:"name,omitempty"`
	// namespace is the namespace of the referent. When unspecified, the local
	// namespace is inferred.
	Namespace string `json:"namespace,omitempty"`
}

