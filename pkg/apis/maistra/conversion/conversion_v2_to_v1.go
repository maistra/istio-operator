package conversion

import (
	"fmt"

	conversion "k8s.io/apimachinery/pkg/conversion"

	"github.com/maistra/istio-operator/pkg/apis/maistra/status"
	v1 "github.com/maistra/istio-operator/pkg/apis/maistra/v1"
	v2 "github.com/maistra/istio-operator/pkg/apis/maistra/v2"
	"github.com/maistra/istio-operator/pkg/controller/versions"
)

func v2ToV1Hacks(values map[string]interface{}, out *v1.ControlPlaneSpec) error {
	// adjustments for 3scale
	// Need to move 3scale out of Istio values into ThreeScale field
	if rawThreeScaleValues, ok := values["3scale"]; ok && rawThreeScaleValues != nil {
		if threeScaleValues, ok := rawThreeScaleValues.(map[string]interface{}); ok {
			out.ThreeScale = v1.NewHelmValues(threeScaleValues)
		} else {
			return fmt.Errorf("could not convert 3scale values to map[string]interface{}")
		}
	}
	delete(values, "3scale")

	hv := v1.NewHelmValues(values)
	rawJaegerValues, ok, err := hv.GetFieldNoCopy("tracing.jaeger")
	if ok {
		jaegerValues, ok := rawJaegerValues.(map[string]interface{})
		if !ok {
			return fmt.Errorf("could not cast tracing.jaeger value to map[string]interface{}: %T", rawJaegerValues)
		}
		// move tracing.jaeger.annotations to tracing.jaeger.podAnnotations
		if jaegerAnnotations, ok, err := hv.GetFieldNoCopy("tracing.jaeger.podAnnotations"); ok {
			if err := hv.SetField("tracing.jaeger.annotations", jaegerAnnotations); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		// normalize jaeger images
		if agentImage, ok, err := hv.GetAndRemoveString("tracing.jaeger.agent.image"); ok {
			if err := hv.SetField("tracing.jaeger.agentImage", agentImage); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		if allInOneImage, ok, err := hv.GetAndRemoveString("tracing.jaeger.allInOne.image"); ok {
			if err := hv.SetField("tracing.jaeger.allInOneImage", allInOneImage); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		if collectorImage, ok, err := hv.GetAndRemoveString("tracing.jaeger.collector.image"); ok {
			if err := hv.SetField("tracing.jaeger.collectorImage", collectorImage); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		if queryImage, ok, err := hv.GetAndRemoveString("tracing.jaeger.query.image"); ok {
			if err := hv.SetField("tracing.jaeger.queryImage", queryImage); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
		delete(jaegerValues, "podAnnotations")
		delete(jaegerValues, "agent")
		delete(jaegerValues, "allInOne")
		delete(jaegerValues, "collector")
		delete(jaegerValues, "query")
	} else if err != nil {
		return err
	}

	if out.Version == versions.V1_1.String() {
		// external jaeger for v1.1
		if zipkinAddress, ok, err := hv.GetString("global.tracer.zipkin.address"); ok && zipkinAddress != "" {
			if err := setHelmBoolValue(values, "tracing.enabled", false); err != nil {
				return err
			}
		} else if err != nil {
			return err
		}
	}

	return nil
}

type namespaceScope struct {
	conversion.Scope
	namespace string
}

// Convert_v2_ServiceMeshControlPlane_To_v1_ServiceMeshControlPlane is an autogenerated conversion function.
func Convert_v2_ServiceMeshControlPlane_To_v1_ServiceMeshControlPlane(
	in *v2.ServiceMeshControlPlane, out *v1.ServiceMeshControlPlane, s conversion.Scope,
) error {
	return autoConvert_v2_ServiceMeshControlPlane_To_v1_ServiceMeshControlPlane(in, out, &namespaceScope{Scope: s, namespace: in.GetNamespace()})
}

// Convert_v2_ControlPlaneSpec_To_v1_ControlPlaneSpec converts a v2 ControlPlaneSpec to an equivalent values.yaml.
// XXX: this requires the following additional details:
//   - namespace - the target namespace for the resource
func Convert_v2_ControlPlaneSpec_To_v1_ControlPlaneSpec(in *v2.ControlPlaneSpec, out *v1.ControlPlaneSpec, s conversion.Scope) error {
	if err := autoConvert_v2_ControlPlaneSpec_To_v1_ControlPlaneSpec(in, out, s); err != nil {
		return err
	}

	version, versionErr := versions.ParseVersion(in.Version)
	if versionErr != nil {
		return versionErr
	}

	if len(in.Profiles) == 1 {
		out.Template = in.Profiles[0]
	}

	// Make a copy so we can modify fields as needed
	in = in.DeepCopy()

	// Initialize output
	// we start with techPreview values, which may be overwritten by "real" configuration
	// this allows us to promote techpreview features into main configuration without
	// worrying about conflicting values
	var values map[string]interface{}
	if in.TechPreview == nil {
		values = make(map[string]interface{})
	} else if errors, ok, _ := in.TechPreview.GetMap("errored"); ok && len(errors) > 0 {
		// there were errors when converting from original v1, so we just copy them back
		if istio, ok, _ := in.TechPreview.GetMap("errored.istio"); ok && len(istio) > 0 {
			out.Istio = v1.NewHelmValues(istio)
		}
		if threeScale, ok, _ := in.TechPreview.GetMap("errored.3scale"); ok && len(threeScale) > 0 {
			out.ThreeScale = v1.NewHelmValues(threeScale)
		}
		return nil
	} else {
		values = in.TechPreview.GetContent()
	}

	namespace := ""
	if namespaceScope, ok := s.(*namespaceScope); ok {
		namespace = namespaceScope.namespace
	}
	if namespace == "" {
		namespace = "istio-system" // a sensible default
	}

	isClusterScoped, err := version.Strategy().IsClusterScoped(in)
	if err != nil {
		return err
	}
	delete(values, v2.TechPreviewControlPlaneModeKey)
	if isClusterScoped {
		if version == versions.V2_3 {
			if err := setHelmBoolValue(values, "global.clusterScoped", isClusterScoped); err != nil {
				return err
			}
		} else if version.AtLeast(versions.V2_4) {
			if err := setHelmBoolValue(values, "global.clusterWide", isClusterScoped); err != nil {
				return err
			}
		}
	}

	// Cluster settings
	// cluster must come first as it may modify other settings on the input (e.g. meshExpansionPorts)
	if err := populateClusterValues(in, namespace, values); err != nil {
		return err
	}

	// General
	if err := populateGeneralValues(in.General, values); err != nil {
		return err
	}

	// Policy
	if err := populatePolicyValues(in, values); err != nil {
		return err
	}

	// Proxy
	if err := populateProxyValues(in, values); err != nil {
		return err
	}

	// Security
	if err := populateSecurityValues(in, values, version); err != nil {
		return err
	}

	// Telemetry
	if err := populateTelemetryValues(in, values); err != nil {
		return err
	}

	// Tracing
	if err := populateTracingValues(in, values); err != nil {
		return err
	}

	// Gateways
	if err := populateGatewaysValues(in, values); err != nil {
		return err
	}

	// Addons
	if err := populateAddonsValues(in, values); err != nil {
		return err
	}

	// Runtime - must run last as this will add values to existing child maps
	if err := populateControlPlaneRuntimeValues(in.Runtime, values); err != nil {
		return err
	}

	if err := v2ToV1Hacks(values, out); err != nil {
		return err
	}

	out.Istio = v1.NewHelmValues(values)

	return nil
}

func Convert_v2_ControlPlaneStatus_To_v1_ControlPlaneStatus(in *v2.ControlPlaneStatus, out *v1.ControlPlaneStatus, s conversion.Scope) error {
	if err := autoConvert_v2_ControlPlaneStatus_To_v1_ControlPlaneStatus(in, out, s); err != nil {
		return err
	}

	// ReconciledVersion requires manual conversion: does not exist in peer-type
	out.ReconciledVersion = status.ComposeReconciledVersion(in.OperatorVersion, in.ObservedGeneration)
	// LastAppliedConfiguration requires manual conversion: does not exist in peer-type
	in.AppliedValues.DeepCopyInto(&out.LastAppliedConfiguration)
	return nil
}
